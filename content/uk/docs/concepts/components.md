---
title: Компоненти
description: Основні компоненти, з яких складається OpenTelemetry
aliases: [data-collection]
weight: 20
default_lang_commit: e05fefe6c9f7d8b159d9a9a95128098c646c78c4
---

OpenTelemetry наразі складається з кількох основних компонентів:

- [Специфікація](#specification)
- [Колектор](#collector)
- [Мовні API та SDK реалізації](#language-specific-api--sdk-implementations)
  - [Бібліотеки інструментування](#instrumentation-libraries)
  - [Експортери](#exporters)
  - [Інструментування без коду](#zero-code-instrumentation)
  - [Детектори ресурсів](#resource-detectors)
  - [Крос-сервісні поширювачі](#cross-service-propagators)
  - [Семплери](#samplers)
- [Kubernetes оператор](#kubernetes-operator)
- [Функції як сервіс](#function-as-a-service-assets)

OpenTelemetry дозволяє замінити необхідність у використанні SDK та інструментів від конкретних постачальників для генерації та експорту телеметричних даних.

## Специфікація {#specification}

Описує міжмовні вимоги та очікування для всіх реалізацій. Окрім визначення термінів, специфікація визначає наступне:

- **API:** Визначає типи даних та операції для генерації та кореляції даних трасування, метрик та логування.
- **SDK:** Визначає вимоги до мовної реалізації API. Тут також визначені концепції конфігурації, обробки даних та експорту.
- **Дані:** Визначає протокол OpenTelemetry (OTLP) та незалежні від постачальника семантичні конвенції, які може підтримувати телеметричний бекенд.

Для отримання додаткової інформації дивіться [специфікації](/docs/specs/).

## Колектор {#collector}

Колектор OpenTelemetry є незалежним від постачальника проксі, який може отримувати, обробляти та експортувати телеметричні дані. Він підтримує отримання телеметричних даних у кількох форматах (наприклад, OTLP, Jaeger, Prometheus, а також багато комерційних/пропрієтарних інструментів) та надсилання даних до одного або кількох бекендів. Він також підтримує обробку та фільтрацію даних телеметрії перед їх експортом.

Для отримання додаткової інформації дивіться [Колектор](/docs/collector/).

## Мовні API та SDK реалізації {#language-specific-api--sdk-implementations}

OpenTelemetry також має мовні SDK, які дозволяють використовувати API OpenTelemetry для генерації телеметричних даних за допомогою обраної мови програмування та експорту цих даних до бажаного бекенду. Ці SDK також дозволяють інтегрувати бібліотеки інструментування для поширених бібліотек та фреймворків, які можна використовувати для підключення до ручного інструментування у вашому застосунку.

Для отримання додаткової інформації дивіться [Інструментування](/docs/concepts/instrumentation/).

### Бібліотеки інструментування {#instrumentation-libraries}

OpenTelemetry підтримує велику кількість компонентів, які генерують відповідні телеметричні дані з популярних бібліотек та фреймворків для підтримуваних мов. Наприклад, вхідні та вихідні HTTP-запити з HTTP-бібліотеки генерують дані про ці запити.

Аспіраційною метою OpenTelemetry є те, щоб усі популярні бібліотеки були стандартно спостережуваними, щоб не було необхідності у використанні окремих залежностей.

Для отримання додаткової інформації дивіться [Бібліотеки інструментування](/docs/concepts/instrumentation/libraries/).

### Експортери {#exporters}

{{% docs/languages/exporters/intro %}}

### Інструментування без коду {#zero-code-instrumentation}

Якщо це можливо, мовна реалізація OpenTelemetry надає спосіб інструментувати ваш застосунок без зміни вихідного коду. Хоча основний механізм залежить від мови, інструментування без коду додає можливості API та SDK OpenTelemetry до вашого застосунку. Крім того, він може додати набір бібліотек інструментування та залежностей експортерів.

Для отримання додаткової інформації дивіться [Інструментування без коду](/docs/concepts/instrumentation/zero-code/).

### Детектори ресурсів {#resource-detectors}

[Ресурс](/docs/concepts/resources/) представляє сутність, що генерує телеметрію як атрибути ресурсу. Наприклад, процес, що генерує телеметрію, який працює у контейнері в Kubernetes, має імʼя Podʼа, простір імен та, можливо, імʼя розгортання. Ви можете включити всі ці атрибути у ресурс.

Мовні реалізації OpenTelemetry забезпечують виявлення ресурсів зі змінної середовища `OTEL_RESOURCE_ATTRIBUTES` та для багатьох поширених сутностей, таких як процес, служба, хост або операційна система.

Для отримання додаткової інформації дивіться [Ресурси](/docs/concepts/resources/).

### Крос-сервісні поширювачі {#cross-service-propagators}

Поширення — це механізм, який переміщує дані між сервісами та процесами. Хоча це не обмежується трасуванням, поширення дозволяє трейсам будувати причинно-наслідкову інформацію про систему через сервіси, які довільно розподілені, через процеси та мережеві межі.

Для більшості випадків використання поширення контексту відбувається через бібліотеки інструментування. Якщо потрібно, ви можете використовувати поширювачі самостійно для серіалізації та десеріалізації різних аспектів, таких як контекст відрізка та [baggage](/docs/concepts/signals/baggage/).

### Семплери {#samplers}

Вибірка — це процес, який обмежує кількість трейсів, що генеруються системою. Кожна мовна реалізація OpenTelemetry пропонує кілька [семплерів заголовків](/docs/concepts/sampling/#head-sampling).

Для отримання додаткової інформації дивіться [Вибірка](/docs/concepts/sampling).

## Kubernetes оператор {#kubernetes-operator}

Оператор OpenTelemetry є реалізацією оператора Kubernetes. Оператор керує Колектором OpenTelemetry та автоматичним інструментуванням робочих навантажень за допомогою OpenTelemetry.

Для отримання додаткової інформації дивіться [K8s Оператор](/docs/platforms/kubernetes/operator/).

## Функції як сервіс {#function-as-a-service-assets}

OpenTelemetry підтримує різні методи моніторингу функцій як сервісу, що надаються різними хмарними постачальниками. Спільнота OpenTelemetry наразі надає попередньо зібрані шари Lambda, які можуть автоматично інструментувати ваш застосунок, а також опцію окремого шару Колектора Lambda, який можна використовувати при інструментуванні застосунків вручну або автоматично.

Для отримання додаткової інформації дивіться [Функції як сервіс](/docs/platforms/faas/).
