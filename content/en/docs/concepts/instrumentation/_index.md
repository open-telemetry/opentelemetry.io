---
title: Instrumentation
description: How OpenTelemetry facilitates instrumentation
aliases: [instrumenting]
weight: 15
---

For a system to be [observable], it must be **instrumented**: that is, code from
the system's components must emit [signals], such as [traces], [metrics], and
[logs].

Using OpenTelemetry, you can instrument your code in three primary ways:

1. [Code-based solutions](code-based/) via official
   [APIs and SDKs for most languages](/docs/languages/)
2. [Assisted solutions](assisted/)
3. [Automatic solutions](automatic/) (or **Zero-Code solutions**)

**Code-based** solutions allow you to get deeper insight and rich telemetry from
your application itself. They let you use the OpenTelemetry API to generate
telemetry from your application, which acts as an essential complement to the
telemetry generated by zero-code solutions.

**Assisted** solutions sit between code-based and automatic solutions. They can
be provided through language-specific convenience packages or through
compile-time instrumentations. Different from automatic/zero-code solutions, they
require some configuration or code changes.

**Automatic** (or **Zero-Code**) solutions are great for getting started, or
when you can't modify the application you need to get telemetry out of. They
provide rich telemetry from libraries you use and/or the environment your
application runs in. Another way to think of it is that they provide information
about what's happening _at the edges_ of your application.

You can use all solutions simultaneously.

{{% alert title="Note" %}}

Which solution is right for you depends on your role and requirements. While
**automatic** and **assisted** are great to add observability to your
application quickly, they are not able to provide deep code-specific telemetry,
which can be accomplished with **code-based** instrumentation.

Additionally, there is no clear boundary between the three solutions presented
above:

- [Language-specific implementations of the API & SDK](/docs/languages) often
  provide convenience functions, which can assist and automate instrumentation
  for a developer.
- An [instrumentation library](/docs/concepts/libraries) is a _code-based_
  instrumentation by the library author, but can be consumed with _zero code
  changes_ by the consumer of the library.
- Compile-time instrumentation is _automatic_ in the sense that a developer does
  not need to touch their code, yet it's different from runtime instrumentation,
  which can be used by Ops without support from a developer.

{{% /alert %}}

## Additional OpenTelemetry Benefits

OpenTelemetry provides more than just zero-code and code-based telemetry
solutions. The following things are also a part of OpenTelemetry:

- Libraries can leverage the OpenTelemetry API as a dependency, which will have
  no impact on applications using that library, unless the OpenTelemetry SDK is
  imported.
- For each of the [signals] you have several methods at your disposal to create,
  process, and export them.
- With [context propagation](../context-propagation/) built into the
  implementations, you can correlate signals regardless of where they are
  generated.
- [Resources](../resources/) and
  [Instrumentation Scopes](../instrumentation-scope/) allow grouping of signals,
  by different entities, like, the [host](/docs/specs/semconv/resource/host/),
  [operating system](/docs/specs/semconv/resource/os/) or
  [K8s cluster](/docs/specs/semconv/resource/k8s/#cluster)
- Each language-specific implementation of the API and SDK follows the
  requirements and expectations of the
  [OpenTelemetry specification](/docs/specs/otel/).
- [Semantic Conventions](../semantic-conventions/) provide a common naming
  schema that can be used for standardization across code bases and platforms.

[logs]: ../signals/logs/
[metrics]: ../signals/metrics/
[observable]: ../observability-primer/#what-is-observability
[signals]: ../signals/
[traces]: ../signals/traces/
