#!/usr/bin/perl -w
#
# Script to update semconv autogenerated mounts in the semconv theme
# by calling print-spec-mounts.pl and replacing the relevant section

use strict;
use warnings;
use diagnostics;

# Configuration
my $HUGO_YAML = "themes/semconv/hugo.yaml";
my $PRINT_SCRIPT = "scripts/content-modules/print-spec-mounts.pl";
my $SEMCONV_DIR = "content-modules/semantic-conventions";
my $SEMCONV_DOCS_DIR = "$SEMCONV_DIR/docs";

# Marker comments in hugo.yaml
sub markerFor($) {
  my ($qualifier) = @_;
  return "# DO NOT EDIT - semconv autogenerated mounts $qualifier - DO NOT EDIT";
}
my $START_MARKER = markerFor("below");
my $END_MARKER = markerFor("above");

sub main() {
  # Find all README.md files using the same command as the original Must be in
  # $SEMCONV_DIR for find to generate the correct relative paths
  my $readme_files = `cd $SEMCONV_DIR && find docs -name "README.md" | sort`;
  chomp $readme_files;

  if (!$readme_files) {
    die "No README.md files found under $SEMCONV_DOCS_DIR\n";
  }

  my $file_count = () = $readme_files =~ /\n/g;
  $file_count++ if $readme_files;  # Count the last line if there's content
  print "Found $file_count README.md files in $SEMCONV_DOCS_DIR\n";

  # Call print-spec-mounts.pl to generate mount entries
  my $mount_entries = generate_mount_entries($readme_files);

  # Update hugo.yaml
  update_hugo_yaml($mount_entries);

  print "Successfully updated hugo.yaml with semconv mount entries\n";
}

sub generate_mount_entries {
  my ($readme_files) = @_;

  # Build command using xargs to properly pass file list as arguments
  my $cmd = "echo '$readme_files' | xargs $PRINT_SCRIPT";
  print "Running: $PRINT_SCRIPT\n";

  my $output = `$cmd`;
  my $exit_code = $? >> 8;

  if ($exit_code != 0) {
    die "print-spec-mounts.pl failed with exit code $exit_code\n";
  }

  return $output;
}

sub update_hugo_yaml {
  my ($new_mount_entries) = @_;

  open(my $read_fh, '<', $HUGO_YAML) or die "Cannot open $HUGO_YAML: $!\n";
  my @lines = <$read_fh>;
  close($read_fh);

  # Find the start and end markers
  my $start_line = -1;
  my $end_line = -1;

  for (my $i = 0; $i < @lines; $i++) {
    # chomp $lines[$i];
    if ($lines[$i] =~ /$START_MARKER/) {
      $start_line = $i;
    } elsif ($lines[$i] =~ /$END_MARKER/) {
      $end_line = $i;
      last;
    }
  }

  die "Marker not found in $HUGO_YAML:\n$START_MARKER\n" if ($start_line == -1);
  die "Marker not found in $HUGO_YAML:\n$END_MARKER\n" if ($end_line == -1);

  # Replace the section between markers
  my @new_file_lines = ();

  # Keep lines before start marker
  for (my $i = 0; $i <= $start_line; $i++) {
    push @new_file_lines, $lines[$i];
  }

  # Add the new mount entries
  my @new_lines = split(/\n/, $new_mount_entries);
  foreach my $line (@new_lines) {
    push @new_file_lines, $line . "\n";
  }

  # Keep lines after end marker
  for (my $i = $end_line; $i < @lines; $i++) {
    push @new_file_lines, $lines[$i];
  }

  # Write the updated file
  open(my $write_fh, '>', $HUGO_YAML) or die "Cannot write to $HUGO_YAML: $!\n";
  print $write_fh @new_file_lines;
  close($write_fh);
}

main();
