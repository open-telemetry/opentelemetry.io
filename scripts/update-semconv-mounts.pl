#!/usr/bin/perl -w
#
# Script to generate module.yaml from module-template.yaml by adding
# autogenerated semconv mount entries. The entries are generated from the list
# of README.md files in the semconv submodule.
#
# Note that this script might be called in situations where some but not all
# content-modules have been initialized. If the semconv submodule is not
# git-submodule initialized, the script will warn and exit.
#
# Reads from: $MODULE_CONFIG_TEMPLATE (version-controlled template) Writes to:
# $MODULE_CONFIG_YAML (generated, gitignored)

use strict;
use warnings;
use diagnostics;

# Configuration
my $MODULE_CONFIG_TEMPLATE = "config/_default/module-template.yaml";
my $MODULE_CONFIG_YAML = "config/_default/module.yaml";
my $SEMCONV_DIR = "content-modules/semantic-conventions";
my $SEMCONV_DOCS_DIR = "$SEMCONV_DIR/docs";

# Marker comments in YAML file to look for
sub markerFor($) {
  my ($qualifier) = @_;
  return "# DO NOT EDIT - semconv autogenerated mounts $qualifier - DO NOT EDIT";
}
my $START_MARKER = markerFor("below");
my $END_MARKER = markerFor("above");

sub main() {
  if (! -e $SEMCONV_DIR) {
    # The directory should be present even if the submodule isn't initialized.
    print STDERR "ERROR: submodule directory not found: $SEMCONV_DIR\n";
    exit 1;
  }

  if (! -e "$SEMCONV_DIR/.git") {
    print STDERR
      "WARNING: submodule not initialized, '.git' directory not found in $SEMCONV_DIR\n" .
      "         Skipping semconv mount config generation.\n" .
      "         Run 'npm run get:submodule' to initialize.\n";
    exit 0;
  } else {
    print STDERR "Submodule found and initialized: $SEMCONV_DIR\n";
  }

  if (! -e $SEMCONV_DOCS_DIR) {
    print STDERR "ERROR: directory '$SEMCONV_DOCS_DIR' expected but not found.\n";
    exit 1;
  }

  # Find all README.md by running system `find`. Must be in
  # $SEMCONV_DIR for find to generate the correct relative paths
  my $readme_files = `cd $SEMCONV_DIR && find docs -name "README.md" | sort`;
  chomp $readme_files;

  if (!$readme_files) {
    die "No README.md files found under $SEMCONV_DOCS_DIR\n";
  }

  my $file_count = () = $readme_files =~ /\n/g;
  $file_count++ if $readme_files;  # Count the last line if there's content
  print "Found $file_count README.md files in $SEMCONV_DOCS_DIR\n";

  # Generate mount entries
  my @mount_entries = generate_mount_entries($readme_files);

  # Generate module.yaml from module-base.yaml
  generate_module_yaml(\@mount_entries);

  print "Successfully generated $MODULE_CONFIG_YAML with semconv mount entries\n";
}

sub generate_mount_entries {
  my ($readme_files) = @_;

  my @mount_entries = ();

  foreach my $path (split(/\n/, $readme_files)) {
    next if $path =~ /^\s*$/;

    $path =~ s|^(./)?docs/||; # strip prefix

    my $target = $path;
    $target =~ s/README\.md$/_index.md/;

    push @mount_entries, "  - source: tmp/semconv/docs/$path\n";
    push @mount_entries, "    target: content/docs/specs/semconv/$target\n";
  }

  return @mount_entries;
}

sub generate_module_yaml {
  my ($new_mount_entries_ref) = @_;

  # Read the template
  open(my $read_fh, '<', $MODULE_CONFIG_TEMPLATE) or die "Cannot open $MODULE_CONFIG_TEMPLATE: $!\n";
  my @lines = <$read_fh>;
  close($read_fh);

  # Find the start and end markers
  my $start_line = -1;
  my $end_line = -1;

  for (my $i = 0; $i < @lines; $i++) {
    if ($lines[$i] =~ /$START_MARKER/) {
      $start_line = $i;
    } elsif ($lines[$i] =~ /$END_MARKER/) {
      $end_line = $i;
      last;
    }
  }

  die "Marker not found in $MODULE_CONFIG_TEMPLATE:\n$START_MARKER\n" if ($start_line == -1);
  die "Marker not found in $MODULE_CONFIG_TEMPLATE:\n$END_MARKER\n" if ($end_line == -1);

  # Build the mount_entries file
  my @new_file_lines = ();

  # Keep lines before start marker
  for (my $i = 0; $i <= $start_line; $i++) {
    push @new_file_lines, $lines[$i];
  }

  # Add the new mount entries
  foreach my $line (@$new_mount_entries_ref) {
    push @new_file_lines, $line;
  }

  # Keep lines after end marker
  for (my $i = $end_line; $i < @lines; $i++) {
    push @new_file_lines, $lines[$i];
  }

  # Write the generated file
  open(my $write_fh, '>', $MODULE_CONFIG_YAML) or die "Cannot write to $MODULE_CONFIG_YAML: $!\n";
  print $write_fh @new_file_lines;
  close($write_fh);
}

main();
